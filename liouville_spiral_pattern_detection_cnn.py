# -*- coding: utf-8 -*-
"""Liouville_Spiral_Pattern_Detection_CNN.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1cR1CoURqp7_HVkESqpBcDX27HfVZBZJh
"""

pip install matplotlib numpy scipy jupyter

import numpy as np
import matplotlib.pyplot as plt

def liouville_lambda(n):
    """Compute λ(n) = (-1)^Ω(n), where Ω(n) is the number of prime factors counted with multiplicity"""
    if n < 1:
        return 0
    omega = 0
    i = 2
    while i * i <= n:
        while n % i == 0:
            omega += 1
            n //= i
        i += 1
    if n > 1:
        omega += 1
    return 1 if omega % 2 == 0 else -1

def generate_ulam_spiral(size):
    """Generate a 2D grid of λ(n) values in an Ulam spiral pattern"""
    grid = np.zeros((size, size), dtype=int)
    x, y = size // 2, size // 2
    dx, dy = 0, -1
    n = 1
    for _ in range(size * size):
        if 0 <= x < size and 0 <= y < size:
            grid[y, x] = liouville_lambda(n)
        if x == y or (x < y and x + y == size - 1) or (x > y and x + y == size):
            dx, dy = -dy, dx
        x, y = x + dx, y + dy
        n += 1
    return grid

def plot_ulam_spiral_lambda(size):
    grid = generate_ulam_spiral(size)
    plt.figure(figsize=(8, 8))
    plt.imshow(grid, cmap='bwr', interpolation='nearest')
    plt.title(f"Liouville λ(n) Ulam Spiral ({size}x{size})")
    plt.axis('off')
    plt.show()

# Generate all requested sizes
sizes = [601]
for s in sizes:
    plot_ulam_spiral_lambda(s)

import numpy as np
import matplotlib.pyplot as plt

def liouville_lambda(n):
    """Compute λ(n) = (-1)^Ω(n), where Ω(n) is the number of prime factors counted with multiplicity"""
    if n < 1:
        return 0
    omega = 0
    i = 2
    while i * i <= n:
        while n % i == 0:
            omega += 1
            n //= i
        i += 1
    if n > 1:
        omega += 1
    return 1 if omega % 2 == 0 else -1

def generate_ulam_spiral(size):
    """Generate a 2D grid of λ(n) values in an Ulam spiral pattern"""
    grid = np.zeros((size, size), dtype=int)
    x, y = size // 2, size // 2
    dx, dy = 0, -1
    n = 1
    for _ in range(size * size):
        if 0 <= x < size and 0 <= y < size:
            grid[y, x] = liouville_lambda(n)
        if x == y or (x < y and x + y == size - 1) or (x > y and x + y == size):
            dx, dy = -dy, dx
        x, y = x + dx, y + dy
        n += 1
    return grid

def plot_ulam_spiral_lambda(size):
    grid = generate_ulam_spiral(size)
    plt.figure(figsize=(8, 8))
    plt.imshow(grid, cmap='bwr', interpolation='nearest')
    plt.title(f"Liouville λ(n) Ulam Spiral ({size}x{size})")
    plt.axis('off')
    plt.show()

# Generate all requested sizes
sizes = [701, 1301, 1401, 1501, 1601, 1701]
for s in sizes:
    plot_ulam_spiral_lambda(s)

import numpy as np

def liouville_lambda(n):
    if n < 1:
        return 0
    omega = 0
    i = 2
    while i * i <= n:
        while n % i == 0:
            omega += 1
            n //= i
        i += 1
    if n > 1:
        omega += 1
    return 1 if omega % 2 == 0 else -1

def generate_ulam_spiral(size):
    grid = np.zeros((size, size), dtype=int)
    x, y = size // 2, size // 2
    dx, dy = 0, -1
    n = 1
    for _ in range(size * size):
        if 0 <= x < size and 0 <= y < size:
            grid[y, x] = liouville_lambda(n)
        if x == y or (x < y and x + y == size - 1) or (x > y and x + y == size):
            dx, dy = -dy, dx
        x, y = x + dx, y + dy
        n += 1
    return grid

def calculate_red_percentage(size):
    grid = generate_ulam_spiral(size)
    total_cells = size * size
    red_cells = np.sum(grid == -1)
    red_percent = (red_cells / total_cells) * 100
    return red_cells, total_cells, red_percent

# Example for 1401
size = 1301
red, total, percent = calculate_red_percentage(size)
print(f"Grid Size: {size}x{size}")
print(f"Red (λ(n) = -1) count: {red}")
print(f"Total cells: {total}")
print(f"Red % of total: {percent:.2f}%")

import numpy as np
import matplotlib.pyplot as plt

def liouville_lambda(n):
    if n < 1:
        return 0
    omega = 0
    i = 2
    while i * i <= n:
        while n % i == 0:
            omega += 1
            n //= i
        i += 1
    if n > 1:
        omega += 1
    return 1 if omega % 2 == 0 else -1

def generate_ulam_spiral(size):
    grid = np.zeros((size, size), dtype=int)
    x, y = size // 2, size // 2
    dx, dy = 0, -1
    n = 1
    for _ in range(size * size):
        if 0 <= x < size and 0 <= y < size:
            grid[y, x] = liouville_lambda(n)
        if x == y or (x < y and x + y == size - 1) or (x > y and x + y == size):
            dx, dy = -dy, dx
        x, y = x + dx, y + dy
        n += 1
    return grid

def analyze_corner_tip(grid, zoom=5):
    size = grid.shape[0]
    # Top-right corner is at [0, size-1]
    y, x = 0, size - 1

    # Determine bounds of zoom window (e.g., 5x5 centered around corner)
    half = zoom // 2
    ymin = max(0, y - half)
    ymax = min(size, y + half + 1)
    xmin = max(0, x - half)
    xmax = min(size, x + half + 1)

    region = grid[ymin:ymax, xmin:xmax]
    red_count = np.sum(region == -1)
    blue_count = np.sum(region == 1)

    print(f"🎯 Top-Right Corner Tip Zoom ({zoom}x{zoom}):")
    print(f"Red (λ=-1): {red_count}")
    print(f"Blue (λ=+1): {blue_count}")
    print(f"Red %: {(red_count / region.size) * 100:.2f}%")
    print(f"Values around corner tip:\n{region}")

    # Visualize
    plt.figure(figsize=(4, 4))
    plt.imshow(region, cmap='bwr', interpolation='nearest')
    plt.title(f"Top-Right Corner Tip ({zoom}x{zoom})")
    plt.axis('off')
    plt.show()

# Test
size = 3001  # You can try 1301, 1201, etc.
grid = generate_ulam_spiral(size)
analyze_corner_tip(grid, zoom=7)  # Zoom in on 7x7 tip area

import numpy as np
import matplotlib.pyplot as plt
import torch
import torch.nn as nn
import torch.optim as optim
from torch.utils.data import Dataset, DataLoader
import random
from collections import Counter # Import Counter for label distribution

# --- Part 1: Liouville Function and Ulam Spiral Generation (Your Code) ---

def liouville_lambda(n):
    """Calculates the Liouville function lambda(n)."""
    if n < 1:
        return 0 # Or handle as error, Liouville is for positive integers
    omega = 0
    i = 2
    while i * i <= n:
        while n % i == 0:
            omega += 1
            n //= i
        i += 1
    if n > 1:
        omega += 1
    return 1 if omega % 2 == 0 else -1 # 1 for +1, -1 for -1

def generate_ulam_spiral(size):
    """Generates an Ulam spiral grid with Liouville lambda(n) values."""
    grid = np.zeros((size, size), dtype=int)
    x, y = size // 2, size // 2
    dx, dy = 0, -1
    n = 1
    steps_taken = 0
    segment_length = 1
    turns_in_segment = 0

    coords_to_n = {}

    while n <= size * size:
        if 0 <= y < size and 0 <= x < size:
            coords_to_n[(y, x)] = n
        else:
            break

        n += 1
        steps_taken += 1

        if steps_taken == segment_length:
            steps_taken = 0
            turns_in_segment += 1
            dx, dy = -dy, dx

            if turns_in_segment % 2 == 0:
                segment_length += 1

        x, y = x + dx, y + dy

    for r in range(size):
        for c in range(size):
            if (r, c) in coords_to_n:
                grid[r, c] = liouville_lambda(coords_to_n[(r, c)])
            else:
                grid[r, c] = 0

    return grid

# --- Part 2: Patch Extraction and Labeling ---

def extract_and_label_patches(grid, patch_size, num_patches_per_type=1000):
    """
    Extracts patches from specific regions of the Ulam spiral and labels them.
    Labels: 0 (predominantly red/-1), 1 (predominantly blue/+1), 2 (mixed)
    """
    size = grid.shape[0]
    patches = []
    labels = []

    # --- ADJUST THESE THRESHOLDS ---
    # Lowered to make it easier for patches to be classified as Red or Blue
    red_threshold = 0.55
    blue_threshold = 0.55

    def get_patch(center_y, center_x):
        half_patch = patch_size // 2
        y_start = max(0, center_y - half_patch)
        y_end = min(size, center_y + half_patch + (patch_size % 2))
        x_start = max(0, center_x - half_patch)
        x_end = min(size, center_x + half_patch + (patch_size % 2))

        patch = grid[y_start:y_end, x_start:x_end]
        if patch.shape[0] != patch_size or patch.shape[1] != patch_size:
            # Pad if patch is at edge and clipped
            padded_patch = np.zeros((patch_size, patch_size), dtype=grid.dtype)
            padded_patch[:patch.shape[0], :patch.shape[1]] = patch
            patch = padded_patch
        return patch

    def label_patch(patch):
        red_count = np.sum(patch == -1)
        blue_count = np.sum(patch == 1)
        total_pixels = patch_size * patch_size
        if total_pixels == 0: return 2

        if (red_count / total_pixels) >= red_threshold:
            return 0 # Predominantly Red (-1)
        elif (blue_count / total_pixels) >= blue_threshold:
            return 1 # Predominantly Blue (+1)
        else:
            return 2 # Mixed

    print("Extracting Antidiagonal patches...")
    for _ in range(num_patches_per_type):
        idx = random.randint(0, size - 1)
        center_y = idx
        center_x = size - 1 - idx
        patch = get_patch(center_y, center_x)
        if patch.shape == (patch_size, patch_size):
            patches.append(patch)
            labels.append(label_patch(patch))

    print("Extracting 'Reverse L' patches...")
    # This is a conceptual region for the "Reverse L" based on your observations
    # It focuses on the top-right corner area, but not the very edge pixel
    corner_start_y = 0
    corner_start_x = size - int(size * 0.15) # Start 15% from right edge
    corner_end_y = int(size * 0.15) # End 15% from top edge
    corner_end_x = size - 1

    for _ in range(num_patches_per_type):
        center_y = random.randint(corner_start_y, corner_end_y)
        center_x = random.randint(corner_start_x, corner_end_x)
        patch = get_patch(center_y, center_x)
        if patch.shape == (patch_size, patch_size):
            patches.append(patch)
            labels.append(label_patch(patch))

    print("Extracting Random patches...")
    for _ in range(num_patches_per_type):
        center_y = random.randint(0, size - 1)
        center_x = random.randint(0, size - 1)
        patch = get_patch(center_y, center_x)
        if patch.shape == (patch_size, patch_size):
            patches.append(patch)
            labels.append(label_patch(patch))

    patches_tensor = torch.tensor(np.array(patches), dtype=torch.float32).unsqueeze(1)
    labels_tensor = torch.tensor(np.array(labels), dtype=torch.long)

    return patches_tensor, labels_tensor

# --- Part 3: Simple CNN Model for Patch Classification ---

class SimpleCNN(nn.Module):
    def __init__(self, patch_size, num_classes):
        super(SimpleCNN, self).__init__()
        self.conv1 = nn.Conv2d(1, 16, kernel_size=3, padding=1)
        self.relu1 = nn.ReLU()
        self.pool1 = nn.MaxPool2d(kernel_size=2, stride=2)

        self.conv2 = nn.Conv2d(16, 32, kernel_size=3, padding=1)
        self.relu2 = nn.ReLU()
        self.pool2 = nn.MaxPool2d(kernel_size=2, stride=2)

        self.flattened_size = (patch_size // 4) * (patch_size // 4) * 32
        self.fc1 = nn.Linear(self.flattened_size, 128)
        self.relu3 = nn.ReLU()
        self.fc2 = nn.Linear(128, num_classes)

    def forward(self, x):
        x = self.pool1(self.relu1(self.conv1(x)))
        x = self.pool2(self.relu2(self.conv2(x)))
        x = x.view(-1, self.flattened_size)
        x = self.relu3(self.fc1(x))
        x = self.fc2(x)
        return x

# --- Part 4: Training and Evaluation Loop ---

def train_and_evaluate_model(patches, labels, patch_size, num_epochs=10, batch_size=32):
    num_classes = 3 # Explicitly set to 3 for our 0, 1, 2 labels

    model = SimpleCNN(patch_size, num_classes)
    criterion = nn.CrossEntropyLoss()
    optimizer = optim.Adam(model.parameters(), lr=0.001)

    dataset = torch.utils.data.TensorDataset(patches, labels)

    # --- Print Label Distribution Before Split ---
    label_counts = Counter(labels.numpy())
    print(f"\nLabel distribution before train/test split: {label_counts}")
    label_map_full = {0: 'Red (-1)', 1: 'Blue (+1)', 2: 'Mixed'}
    for label_val, count in label_counts.items():
        print(f"  {label_map_full[label_val]}: {count} samples")


    train_size = int(0.8 * len(dataset))
    test_size = len(dataset) - train_size
    train_dataset, test_dataset = torch.utils.data.random_split(dataset, [train_size, test_size])

    # --- Check label distribution in test set ---
    test_labels_list = [label.item() for _, label in test_dataset]
    test_label_counts = Counter(test_labels_list)
    print(f"\nLabel distribution in TEST set: {test_label_counts}")
    for label_val, count in test_label_counts.items():
        print(f"  {label_map_full[label_val]}: {count} samples")


    train_loader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)
    test_loader = DataLoader(test_dataset, batch_size=batch_size, shuffle=False)

    print(f"\nTraining Simple CNN on {len(train_dataset)} patches, validating on {len(test_dataset)} patches...")

    for epoch in range(num_epochs):
        model.train()
        running_loss = 0.0
        for inputs, targets in train_loader:
            optimizer.zero_grad()
            outputs = model(inputs)
            loss = criterion(outputs, targets)
            loss.backward()
            optimizer.step()
            running_loss += loss.item() * inputs.size(0)

        epoch_loss = running_loss / len(train_dataset)
        print(f"Epoch {epoch+1}/{num_epochs}, Loss: {epoch_loss:.4f}")

    model.eval()
    correct = 0
    total = 0
    with torch.no_grad():
        for inputs, targets in test_loader:
            outputs = model(inputs)
            _, predicted = torch.max(outputs.data, 1)
            total += targets.size(0)
            correct += (predicted == targets).sum().item()

    accuracy = 100 * correct / total
    print(f"\nModel Accuracy on Test Set: {accuracy:.2f}%")

    class_correct = list(0. for i in range(num_classes))
    class_total = list(0. for i in range(num_classes))
    with torch.no_grad():
        for inputs, targets in test_loader:
            outputs = model(inputs)
            _, predicted = torch.max(outputs, 1)
            c = (predicted == targets).squeeze()
            # Ensure c is a 1D tensor for iteration
            if c.dim() == 0: # Handle batch_size=1 case
                c = c.unsqueeze(0)
            if targets.dim() == 0: # Handle batch_size=1 case
                targets = targets.unsqueeze(0)

            for i in range(len(targets)):
                label = targets[i]
                class_correct[label] += c[i].item()
                class_total[label] += 1

    print("\nAccuracy per class:")
    for i in range(num_classes):
        if class_total[i] > 0:
            print(f"  {label_map_full[i]}: {100 * class_correct[i] / class_total[i]:.2f}% ({class_total[i]} samples)")
        else:
            print(f"  {label_map_full[i]}: No samples in test set for this class.")

# --- Main Execution ---
if __name__ == "__main__":
    SPIRAL_SIZE = 5001
    PATCH_SIZE = 16
    NUM_PATCHES_PER_TYPE = 5000 # Increased number of patches

    print(f"Generating Ulam spiral of size {SPIRAL_SIZE}x{SPIRAL_SIZE}...")
    ulam_grid = generate_ulam_spiral(SPIRAL_SIZE)
    print("Ulam spiral generated.")

    print(f"Extracting and labeling patches (Patch Size: {PATCH_SIZE}x{PATCH_SIZE})...")
    all_patches, all_labels = extract_and_label_patches(ulam_grid, PATCH_SIZE, NUM_PATCHES_PER_TYPE)
    print(f"Total patches extracted: {len(all_patches)}")

    # Corrected cmap for visualization to 'bwr' for Red/Blue/White
    fig, axes = plt.subplots(1, 6, figsize=(12, 2))
    sample_indices = random.sample(range(len(all_patches)), 6)
    label_map_full = {0: 'Red', 1: 'Blue', 2: 'Mixed'}
    for i, idx in enumerate(sample_indices):
        ax = axes[i]
        # Use 'bwr' colormap, and set vmin/vmax to ensure -1 is one extreme, 1 is the other
        ax.imshow(all_patches[idx].squeeze().numpy(), cmap='bwr', vmin=-1, vmax=1, origin='lower')
        ax.set_title(f"Label: {label_map_full[all_labels[idx].item()]}")
        ax.axis('off')
    plt.suptitle("Sample Patches")
    plt.tight_layout()
    plt.show()

    train_and_evaluate_model(all_patches, all_labels, PATCH_SIZE, num_epochs=15, batch_size=64)

import numpy as np
import matplotlib.pyplot as plt

# --- Part 1: Liouville Function and Ulam Spiral Generation (Your Code) ---

def liouville_lambda(n):
    """Calculates the Liouville function lambda(n)."""
    if n < 1:
        return 0
    omega = 0
    i = 2
    while i * i <= n:
        while n % i == 0:
            omega += 1
            n //= i
        i += 1
    if n > 1:
        omega += 1
    return 1 if omega % 2 == 0 else -1 # 1 for +1, -1 for -1

def generate_ulam_spiral_and_numbers(size):
    """
    Generates an Ulam spiral grid with Liouville lambda(n) values
    and a separate grid with the actual n values.
    """
    lambda_grid = np.zeros((size, size), dtype=int)
    n_grid = np.zeros((size, size), dtype=int) # To store actual n values

    x, y = size // 2, size // 2
    dx, dy = 0, -1
    n = 1
    steps_taken = 0
    segment_length = 1
    turns_in_segment = 0

    coords_to_n = {}

    while n <= size * size:
        if 0 <= y < size and 0 <= x < size:
            coords_to_n[(y, x)] = n
        else:
            break

        n += 1
        steps_taken += 1

        if steps_taken == segment_length:
            steps_taken = 0
            turns_in_segment += 1
            dx, dy = -dy, dx

            if turns_in_segment % 2 == 0:
                segment_length += 1

        x, y = x + dx, y + dy

    # Populate both grids
    for r in range(size):
        for c in range(size):
            if (r, c) in coords_to_n:
                current_n = coords_to_n[(r, c)]
                n_grid[r, c] = current_n
                lambda_grid[r, c] = liouville_lambda(current_n)
            else:
                n_grid[r, c] = 0 # Mark as empty or outside spiral bounds
                lambda_grid[r, c] = 0 # Neutral value for empty spots

    return lambda_grid, n_grid

# --- Function to Extract Red N-values from a Region ---

def extract_red_n_values_from_region(lambda_grid, n_grid, region_coords):
    """
    Extracts the actual 'n' values from a specified region where lambda(n) is -1 (red).

    Args:
        lambda_grid (np.ndarray): Grid with lambda(n) values (-1 or 1).
        n_grid (np.ndarray): Grid with actual integer 'n' values.
        region_coords (tuple): (ymin, ymax, xmin, xmax) defining the rectangular region.

    Returns:
        list: A list of 'n' values where lambda(n) is -1 within the region.
    """
    ymin, ymax, xmin, xmax = region_coords
    red_n_values = []

    for r in range(ymin, ymax):
        for c in range(xmin, xmax):
            if 0 <= r < lambda_grid.shape[0] and 0 <= c < lambda_grid.shape[1]: # Ensure within grid bounds
                if lambda_grid[r, c] == -1: # If it's a red pixel
                    red_n_values.append(n_grid[r, c])
    return red_n_values

# --- Helper Function for Prime Factorization (Needed for Omega(n)) ---
def count_prime_factors_with_multiplicity(num):
    """Counts total prime factors (Omega(n)) for a number."""
    if num <= 1:
        return 0
    count = 0
    d = 2
    temp_num = num
    while d * d <= temp_num:
        while temp_num % d == 0:
            count += 1
            temp_num //= d
        d += 1
    if temp_num > 1: # Remaining number is a prime factor
        count += 1
    return count

# --- Main Execution for Characterization ---
if __name__ == "__main__":
    SPIRAL_SIZE = 5001 # Start with a size where you clearly saw the L
    # Define the top-right corner region where you observe the 'Reverse L'
    # These coordinates might need fine-tuning based on your visual inspection
    # This is a 15% x 15% square from the top-right
    corner_percentage = 0.15
    corner_pixels = int(SPIRAL_SIZE * corner_percentage)

    # ymin, ymax, xmin, xmax for the region (remember y=0 is top row)
    region_ymin = 0
    region_ymax = corner_pixels
    region_xmin = SPIRAL_SIZE - corner_pixels
    region_xmax = SPIRAL_SIZE

    print(f"Generating Ulam spiral for size {SPIRAL_SIZE}x{SPIRAL_SIZE}...")
    lambda_grid, n_grid = generate_ulam_spiral_and_numbers(SPIRAL_SIZE)
    print("Ulam spiral generated.")

    print(f"Extracting 'n' values for red pixels in the top-right {corner_percentage*100:.0f}% corner region...")
    red_n_values = extract_red_n_values_from_region(lambda_grid, n_grid,
                                                    (region_ymin, region_ymax, region_xmin, region_xmax))

    print(f"\nFound {len(red_n_values)} red 'n' values in the specified region.")

    if red_n_values:
        print("\nAnalyzing properties of the first 20 red 'n' values:")
        for i, n_val in enumerate(red_n_values[:20]):
            omega_n = count_prime_factors_with_multiplicity(n_val)
            print(f"n = {n_val:<8}, Omega(n) = {omega_n:<3}, λ(n) = {liouville_lambda(n_val)}")
            if liouville_lambda(n_val) != -1:
                print(f"  WARNING: Expected λ(n)=-1 for n={n_val}, but got {liouville_lambda(n_val)}. Check region definition or lambda calculation.")

        print("\nCommon properties to look for (manually inspect the list):")
        print("- Are they mostly odd or even?")
        print("- Do they have a common factor (e.g., all multiples of 3, 5, 7, etc.)?")
        print("- Do they seem to follow a polynomial sequence (e.g., n^2 + an + b)?")
        print("- Are their Omega(n) values consistently odd (as expected for λ(n)=-1)?")
        print("- Are there any perfect squares or near-squares among them? (λ(square) is always +1, so these would be exceptions if found in a red region)")

    else:
        print("No red values found in the specified region. Adjust region_coords or spiral_size.")

import numpy as np
import matplotlib.pyplot as plt

def liouville_lambda(n):
    if n < 1: return 0
    omega = 0
    i = 2
    while i * i <= n:
        while n % i == 0:
            omega += 1
            n //= i
        i += 1
    if n > 1:
        omega += 1
    return 1 if omega % 2 == 0 else -1

def generate_ulam_spiral_and_numbers(size):
    lambda_grid = np.zeros((size, size), dtype=int)
    n_grid = np.zeros((size, size), dtype=int)
    n_to_coords = {} # New: Map n to (y, x)

    x, y = size // 2, size // 2
    dx, dy = 0, -1
    n = 1
    steps_taken = 0
    segment_length = 1
    turns_in_segment = 0

    while n <= size * size:
        if 0 <= y < size and 0 <= x < size:
            n_grid[y, x] = n
            lambda_grid[y, x] = liouville_lambda(n)
            n_to_coords[n] = (y, x) # Store the coordinate for n
        else:
            break

        n += 1
        steps_taken += 1

        if steps_taken == segment_length:
            steps_taken = 0
            turns_in_segment += 1
            dx, dy = -dy, dx

            if turns_in_segment % 2 == 0:
                segment_length += 1

        x, y = x + dx, y + dy

    return lambda_grid, n_grid, n_to_coords # Return the new dictionary

def extract_red_n_values_from_region(lambda_grid, n_grid, region_coords):
    ymin, ymax, xmin, xmax = region_coords
    red_n_values = []

    for r in range(ymin, ymax):
        for c in range(xmin, xmax):
            if 0 <= r < lambda_grid.shape[0] and 0 <= c < lambda_grid.shape[1]:
                if lambda_grid[r, c] == -1:
                    red_n_values.append(n_grid[r, c])
    return red_n_values

def count_prime_factors_with_multiplicity(num):
    if num <= 1: return 0
    count = 0
    d = 2
    temp_num = num
    while d * d <= temp_num:
        while temp_num % d == 0:
            count += 1
            temp_num //= d
        d += 1
    if temp_num > 1:
        count += 1
    return count

# Main Execution for Characterization
if __name__ == "__main__":
    SPIRAL_SIZE = 501 # Start with a size where you clearly saw the L
    corner_percentage = 0.15
    corner_pixels = int(SPIRAL_SIZE * corner_percentage)

    region_ymin = 0
    region_ymax = corner_pixels
    region_xmin = SPIRAL_SIZE - corner_pixels
    region_xmax = SPIRAL_SIZE

    print(f"Generating Ulam spiral for size {SPIRAL_SIZE}x{SPIRAL_SIZE}...")
    lambda_grid, n_grid, n_to_coords = generate_ulam_spiral_and_numbers(SPIRAL_SIZE) # Get n_to_coords
    print("Ulam spiral generated.")

    print(f"Extracting 'n' values for red pixels in the top-right {corner_percentage*100:.0f}% corner region...")
    red_n_values = extract_red_n_values_from_region(lambda_grid, n_grid,
                                                    (region_ymin, region_ymax, region_xmin, region_xmax))

    print(f"\nFound {len(red_n_values)} red 'n' values in the specified region.")

    # --- New: Extract and Analyze Coordinates of Red Pixels ---
    red_coords = []
    for n_val in red_n_values:
        if n_val in n_to_coords: # Ensure n_val is valid (not 0 from padding)
            red_coords.append(n_to_coords[n_val])

    print(f"\nAnalyzing coordinates of {len(red_coords)} red pixels:")
    if red_coords:
        # Plotting the coordinates to visualize the 'L'
        y_coords = [coord[0] for coord in red_coords]
        x_coords = [coord[1] for coord in red_coords]

        plt.figure(figsize=(8, 8))
        plt.scatter(x_coords, y_coords, s=1, color='red', alpha=0.5) # s=1 for small dots
        plt.title(f"Red Pixels in Top-Right Corner (Size {SPIRAL_SIZE})")
        plt.gca().set_aspect('equal', adjustable='box') # Make sure it's square
        plt.xlim(region_xmin, region_xmax) # Zoom into the region
        plt.ylim(region_ymin, region_ymax) # Zoom into the region
        plt.gca().invert_yaxis() # Invert y-axis to match image convention (y=0 at top)
        plt.show()

        # Analyze coordinate patterns (first 20 for brevity)
        print("\nFirst 20 red pixel coordinates (y, x):")
        for i, coord in enumerate(red_coords[:20]):
            print(f"({coord[0]:<4}, {coord[1]:<4})")

        # Look for polynomial relationships in coordinates
        # This is a manual inspection step initially
        print("\nLook for patterns in coordinates:")
        print("- Do they form straight lines? What are their slopes?")
        print("- Do they form curves? Can you fit a polynomial (y = ax^2 + bx + c or x = ay^2 + by + c)?")
        print("- What is their distance from the top edge (y) and right edge (x_max - x)?")

    else:
        print("No red coordinates found.")

    # (Optional: Keep the n-value analysis from before if you want to re-run it)
    # print("\nAnalyzing properties of the first 20 red 'n' values:")
    # for i, n_val in enumerate(red_n_values[:20]):
    #     omega_n = count_prime_factors_with_multiplicity(n_val)
    #     print(f"n = {n_val:<8}, Omega(n) = {omega_n:<3}, λ(n) = {liouville_lambda(n_val)}")